{
  parserClass="com.apophenic.csharpplugin.parser.CSharpParser"
  parserUtilClass="com.apophenic.csharpplugin.parser.CSharpParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CSharp"
  psiImplClassSuffix="Impl"
  psiPackage="com.apophenic.csharpplugin.psi"
  psiImplPackage="com.apophenic.csharpplugin.psi.impl"

  elementTypeHolderClass="com.apophenic.csharpplugin.psi.CSharpTypes"
  elementTypeClass="com.apophenic.csharpplugin.CSharpElementType"
  tokenTypeClass="com.apophenic.csharpplugin.CSharpTokenType"

  psiImplUtilClass="com.apophenic.csharpplugin.psi.impl.CSharpPropertyImpl"
  generateTokenAccessors=true

  tokens=[
      LBRACE               =  '{'
      RBRACE               =  '}'
      LBRACK               =  '['
      RBRACK               =  ']'
      LPAREN               =  '('
      RPAREN               =  ')'
      COLON                =  ':'
      SEMI                 =  ';'
      COMMA                =  ','
      EQ                   =  '=='
      ASSIGN               =  '='
      NOT_EQ               =  '!='
      NOT                  =  '!'
      PLUS_PLUS            =  '++'
      PLUS_ASSIGN          =  '+='
      PLUS                 =  '+'
      MINUS_MINUS          =  '--'
      MINUS_ASSIGN         =  '-='
      MINUS                =  '-'
      COND_OR              =  '||'
      BIT_OR_ASSIGN        =  '|='
      BIT_CLEAR_ASSIGN     =  '&^='
      BIT_CLEAR            =  '&^'
      COND_AND             =  '&&'
      BIT_AND_ASSIGN       =  '&='
      BIT_AND              =  '&'
      BIT_OR               =  '|'
      SHIFT_LEFT_ASSIGN    =  '<<='
      SHIFT_LEFT           =  '<<'
      LESS_OR_EQUAL        =  '<='
      LESS                 =  '<'
      BIT_XOR_ASSIGN       =  '^='
      BIT_XOR              =  '^'
      MUL_ASSIGN           =  '*='
      MUL                  =  '*'
      QUOTIENT_ASSIGN      =  '/='
      QUOTIENT             =  '/'
      REMAINDER_ASSIGN     =  '%='
      REMAINDER            =  '%'
      SHIFT_RIGHT_ASSIGN   =  '>>='
      SHIFT_RIGHT          =  '>>'
      GREATER_OR_EQUAL     =  '>='
      GREATER              =  '>'
      DOT                  =  '.'
      APOS                 =  ''''
      QUOTE                =  '"'
      BACK                 =  '\'

      WS                   = 'regexp:\s+'
      COMMENT              = 'regexp://.*'
      DIGIT                = 'regexp:\d+(\.\d*)?'
      STRING               = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
      ID                   = 'regexp:\p{Alpha}\w*'
    ]
}

File ::= ImportList NamespaceDec
ImportList ::= ImportDec*
ImportDec ::= using ID (ID | DOT)* SEMI
NamespaceDec ::= namespace ID LBRACE ClassList RBRACE
ClassList ::= ClassDec*
ClassDec ::= (AccessModifier? TypeModifier? ReferenceTypes ID LBRACE MethodList RBRACE)
MethodList ::= (MethodDec | EnumDec | VarDec)*
MethodDec ::= AccessModifier? TypeModifier* Return_type ID LPAREN ((Types | CustomObject) ID ','?)* RPAREN LBRACE
Expr* RBRACE
{pin=8}
EnumDec ::= AccessModifier? enum ID LBRACE (ID ',')* ID* RBRACE


Expr ::= (VarDec | QualifiedClassDec | Switch | Using | Return | MethodCall | Property)

VarDec ::= AccessModifier? TypeModifier? (BoolDec | ByteDec | CharDec | FloatDec | IntDec |
                                          StringDec | ObjectDec | CustomObjectDec | ListDec |
                                          NewTypeDec | PreprocessorDec)


BoolDec ::= bool ID ASSIGN (true | false) SEMI {pin=2}
ByteDec ::= byte ID ASSIGN (0x DIGIT+) SEMI {pin=2} // todo
CharDec ::= char ID ASSIGN APOS ([a-zA-Z0-9] | (BACK ('u' | 'x') DIGIT{4})) APOS SEMI {pin=2}
FloatDec ::= float ID ASSIGN DIGIT '.'? 'f' SEMI {pin=2}
IntDec ::= u?(int | long | short) ID ASSIGN DIGIT SEMI {pin=3}
StringDec ::= 'string' ID ASSIGN STRING SEMI {pin=2}
ObjectDec ::= object ID ASSIGN new object LPAREN (ID | DIGIT | STRING) RPAREN SEMI {pin=2}
CustomObjectDec ::= CustomObject ID ASSIGN (Cast (ID | DIGIT | STRING) | new CustomObject LPAREN (ID | DIGIT | STRING)
                    RPAREN) SEMI {pin=2}
ListDec ::= List '<' (Types | CustomObject) '>' ID ASSIGN new List '<' (Types | CustomObject) '>' LPAREN RPAREN SEMI

NewTypeDec ::= Types ID ASSIGN new Types SEMI

QualifiedClassDec ::= 'System' ('.' ID)+ Argument SEMI {pin=2}


Parameter ::= ID LPAREN ((Types | CustomObject) ID ','*)* RPAREN
Argument ::= LPAREN ((Property | CustomObject) ','?)* RPAREN
Invocation ::= new (QualifiedClassDec | Types | CustomObject) Argument?

MethodCall ::= (QualifiedClassDec | ID) ('.'(QualifiedClassDec | ID))? Argument? SEMI
Property ::= CustomObject '.' ID

Switch ::= switch LPAREN ID RPAREN LBRACE (case LPAREN Expr* RPAREN ':')* default ':' Expr* RBRACE
Using ::= using LPAREN CustomObject ID ASSIGN Invocation RPAREN LBRACE Expr* RBRACE {pin=9}
Return ::= return Expr


Types ::= (bool | byte | sbyte | char | decimal | double | float | int | uint | long | ulong | object | short |
           ushort | 'string') Array?    // todo
ValueTypes ::= (struct | enum)
ReferenceTypes ::= (class | interface | delegate)

PreprocessorDec ::= '#'(if | else | elif | endif | define | undef | warning | error | line | region |
                        endregion | pragma | pragma warning | pragma checksum) ID+
AccessModifier ::= (public | private | protected | internal)
TypeModifier ::= (abstract | async | const | event | extern | new | override | partial | readonly | sealed |
                  static | unsafe | virtual | volatile) // todo split into method modifiers w/ rules

ReservedWords ::= (as | base | break | case | catch | continue | do | else | false | finally | for | foreach | goto |
                   if | in | is | lock | namespace | new | null | out | ref | return | sizeof | stackalloc | switch |
                   this | throw | true | try | typeof | using | while | var | yield)

private Return_type ::= (void | Types | CustomObject)
private Cast ::= LPAREN (Types | CustomObject) RPAREN
private CustomObject ::= ID Array?
private Array ::= LBRACK (ID | DIGIT | STRING)? RBRACK


